<h1> Лабораторная работа №3 "Мини алгоритмический пакет" </h1>
<hr>
<p>Пакет содержит разные алгоритмы сортировок, факториала и чисел Фибоначчи, а также реализацию стека и очереди</p>

<p>Поддерживает следующие команды:</p>
<ul>
    <li> fact        -   выводит факториал. Флаг -r расчитывает его рекурсивно </li>
    <li> fibo        -   выводит элемент чисел Фибоначчи. Флаг -r расчитывает его рекурсивно </li>
    <li> bubble      -   выводит массив, отсортированный пузырьком </li>
    <li> quick       -   выводит массив, отсортированный быстрой сортировкой </li>
    <li> counting    -   выводит массив, отсортированный подсчётом </li>
    <li> radix       -   выводит массив, отсортированный по разрядам </li>
    <li> bucket      -   выводит массив, отсортированный корзинами </li>
    <li> heap        -   выводит массив, отсортированный кучей </li>
    <li> s-push      -   кладёт число в стек </li>
    <li> s-pop       -   вытаскивает верхнее число из стека </li>
    <li> s-peek      -   смотрит верхнее число в стеке </li>
    <li> s-is-empty  -   проверяет стек на наполненность </li>
    <li> s-len       -   возвращает длину стека </li>
    <li> s-min       -   возвращает минимум стека </li>
    <li> q-enqueue   -   кладёт число в очередь </li>
    <li> q-dequeue   -   вытаскивает верхнее число из очереди </li>
    <li> q-front     -   смотрит верхнее число в очереди </li>
    <li> q-is-empty  -   проверяет очередь на наполненность </li>
    <li> q-len       -   возвращает длину очереди </li>
    <li> spin        -   сделать крутку </li>
    <li> slot-bet    -   изменить ставку в слоте </li>
    <li> poker       -   сыграть в видеопокер </li>
    <li> poker-bet   -   изменить ставку в видеопокере </li>
    <li> black       -   сыграть в блекджек </li>
</ul>

<p2> Структура </p2>
<pre>
    .
    ├── lab3
    │   ├── src/                               # Папка с кодом
    │       ├── __init__.py                    #
    │       ├── main.py                        # Точка входа
    │       ├── constants.py                   # Константы
    │       ├── math_func.py                   # Факториал и Фибоначчи
    │       ├── sorts.py                       # Сортировки
    │       ├── utilities/                     # Утилиты
    │           ├── check_list.py              # Функция определения типов для сортировок
    │           ├── structure_tools.py         # Функция определения целых чисел для стека и очереди
    │           ├── card_wrap.py               # Окрашивание карт
    │       ├── stack/                         # Стек
    │           ├── data.bin                   # Данные стека
    │           ├── stack.py                   # Модуль стека
    │       ├── queue/                         # Очередь
    │           ├── data.bin                   # Данные очереди
    │           ├── queue.py                   # Модуль очереди
    │       ├── kasino/                        # Казино
    │           ├── data.bin                   # Данные казино
    │           ├── blackjack.py               # Модуль блекджека
    │           ├── videopoker.py              # Модуль видеопокера
    │           ├── slot/                      # Слот
    │               ├── sounds/                # Звуки(формат: ogg)
    │               ├── slot.py                # Модуль слота
    │   ├── tests/                             # Юниттесты
    │   ├── .gitignore                         # Файл, который не даёт мусорить в гите
    │   ├── .pre-commit-config.yaml            # Конфигурация любимого pre-commit
    |   ├── pyproject.toml                     # Информация по проекту(для системы)
    |   ├── README.md                          # Документация
    │   ├── requirements.txt                   # Зависимости проекта
    |   ├── uv.lock                            # зависимости проекта
</pre>

<h2> Алгоритмы </h2>

<h3> bubble_sort </h3>
    <p>Постепенно переводит старшие элементы к концу списка</p>

<h3> quick_sort </h3>
    <p>Берётся опорный элемент, затем исходный список делится на 3: с элементами, меньше опорного, равного опорному и больше его</p>

<h3> counting_sort </h3>
    <p>Расчитывается разница между максимальным и минимальным элементом, и эта разница - длина массива счётчиков. Затем элементы исходного списка становятся индексами, смещёнными на минимум, по этим индексам происходит увеличение счётчиков из списка. Затем собирается итоговый список по списку счётчиков</p>

<h3> radix_sort </h3>
    <p>Числа приводятся к одной длине незначащами нулями. Создаётся список пустых списков(количество - основание системы счисления). Затем элементы исходного списка раскладываются по этим спискам(индекс нужного списка - значение текущего разряда элемента). После списки из списка списков соединяются вместе, и процесс повторяется по следующему разряду</p>

<h3> bucket_sort </h3>
    <p>Считается минимум списка и разность максимума и минимума. Создаётся список, в котором лежат пустые списки(количество - длина сортируемого списка(по умолчанию) или введённое пользователем число). Вычисляем индекс каждого элемента в списке списков. Сортируем полученные списки, затем последовательно соединяем их в итоговый список</p>

<h3> build_tree </h3>
    <p>Перемещает малые элементы от корня к "листьям", сравнивая текущий корневой элемент с дочерними и при замене вызывая функцию повторно от нового индекса исходного(при запуске функции) корня</p>

<h3> heap_sort </h3>
    <p>Выстраиваем дерево, применяя build_tree к каждому элементу с конца. Затем, идя по дереву с конца, меняем текущий элемент с первым, затем применяем к новому первому элементу buld_tree с областью видимости, равной текущему индексу</p>

<h3> Stack </h3>
    <p>Структура стека: список, в котором на чётных индексах - собственно элементы, а на нечётных - текущие минимумы. Метод push добавляет элемент в стек и расчитывает новый минимум. Метод peek возвращает последний элемент стека, не удаляя его. Метод pop возвращает последний элемент стека, удаляя его. Метод is_empty проверяет, пуст ли стек. Метод __len__ возвращает длину стека. Метод min возвращает минимум стека</p>

<h3> Queue </h3>
    <p>Структура очереди: список, в котором новые элементы добавляются в начало, а старые берутся с конца. Метод enqueue добавляет элемент в начало очереди. Метод front возвращает последний элемент очереди, не удаляя его. Метод dequeue возвращает последний элемент очереди, удаляя его. Метод is_empty проверяет, пуста ли очередь. Метод __len__ возвращает длину очереди</p>

<h3> Логирование </h3>
    <p>Для логирования используется 4 декоратора: check_data_base, structure_data_log, kasik_log и create_log. check_data_base проверяет инициализацию данных и инициализацию классов, записывает лог выполнения/ошибки. structure_data_log проверяет работу структур данных, записывает лог выполнения/ошибки(в лог также записывается текущее наполнение структуры данных). kasik_log проверяет работу методов казино(см. ниже), в лог, кроме результата, также пишется выигрыш и состояние данных после выполнения программы. create_log просто пишет лог выполнения/ошибки.</p>

<hr>

<h2> Бонус </h2>

<p>От создателя "Consol calculator" и "Mini-shell"</p>

<h2> Казино </h2>
    <p>Устали работать? Надоело сортировать списки? Закрыли чат с крутками в Telegram? Тогда вам сюда! В нашем казино есть Слот "Ludoman777", Блекджек и Видеопокер, выбирайте по своему вкусу. В ходе написания этой программы была проведена масштабная исследовательская работа(чтение Википедии и игра в другое казино), чтобы сделать игру по возможности максимально интересной. А если вы (вдруг) проиграли все деньги, приходите завтра, и вам начислят 500 GC(Goose-Coins)</p>

<h3> Слот "Ludoman777" </h3>
    <p>В нашем слоте вы можете делать 2 действия: запустить автомат(команда spin) и изменить ставку(команда slot-bet n, где n - число от 1 до 3 включительно - номер ставки). При запуске автомата звучит приветствие, затем запускаются барабаны слота, после их постепенной остановки идёт расчёт и выплата выигрыша. Ставить можно только 10, 25 и 50 GK за раз. Джекпот - 10000 GC!</p>

<h3> Видеопокер </h3>
    <p>В нашем видеопокере вы можете делать 2 действия: сыграть в покер(команда poker) и изменить ставку(команда poker-bet n, где  n - число от 1 до 5 включительно - номер ставки). При запуске игры выкладывается 5 карт. Пользователь может выбрать удерживаемые карты, прописав их номера, или заменить все(замена проводится лишь раз!). После идёт анализ карточных комбинаций и выплата выигрыша. Джекпот - 500000 GC!</p>

<h3> Блекджек </h3>
    <p>В блекджеке можно сделать только 1 действие - сыграть(команда black n, где n - ставка(от 25 до 500 включительно)). При начале игры выкладываются 2 группы по 2 карты: рука игрока и рука дилера, при этом у последнего закрыта верхняя карта. Над руками можно увидеть число - текущая сила руки. Если не выпал сразу блекджек, игрок может сделать следующие действия: взять карту(команда more, можно выполнять сколько угодно, пока сила руки игрока меньше 21), взять карту и удвоить ставку(команда double, можно выполнить лишь раз и только как первое действие) или оставить как есть. После ходов игрока дилер вскрывает свою карту и при необходимости добирает, пока сила его руки не будет минимум 17. Затем идёт расчёт и выплата выигрыша. Максимальный выигрыш - 1250 GC</p>

<p>Удачной игры!</p>
<hr>
<p>PS: Untronix0nly, понимаю, что казино немного не в тему, но пока писал основную часть, я вошёл в поток и решил написать его сюда. К тому же казино - это тоже алгоритм, а значит его можно засунуть сюда(на самом деле я слишком поздно узнал про тему следующей лабораторной)</p>
